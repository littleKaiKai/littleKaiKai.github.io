<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客、前端"><title>深入了解React的子组件 - Max Stoibers Blog | 凯小木的个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入了解React的子组件 - Max Stoibers Blog</h1><a id="logo" href="/.">凯小木的个人博客</a><p class="description">天道酬勤</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">深入了解React的子组件 - Max Stoibers Blog</h1><div class="post-meta"><a href="/2017/07/31/深入了解React的子组件---Max-Stoibers-Blog/#comments" class="comment-count"></a><p><span class="date">Jul 31, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><blockquote>
<p>翻译于众成翻译</p>
</blockquote>
<p>React的核心是组件。你可以像嵌套HTML标签一样来嵌套这些组件，这使得写JSX变得容易，因为他和标记语言很像。<br>当刚开始学习React的时候，我认为“会用<code>props.children</code>，我就知道了关于子组件的一切”。难道，我有错吗？<br>因为我们在使用JavaScript，我们可以改变子组件。我们可以向他们发送特定的属性，决定我们是否希望它们显示，并且可以按照我们的意愿操作它们。让我们探究一下React中的子组件。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><p><a href="#child-components">子组件</a></p>
<ul>
<li><p><a href="#everything-can-be-a-child">一切都可以是子组件</a></p>
</li>
<li><p><a href="#function-as-a-child">函数子组件</a></p>
</li>
</ul>
</li>
<li><p><a href="#manipulating-children">操控子组件</a></p>
<ul>
<li><p><a href="#looping-over-children">遍历子组件</a></p>
</li>
<li><p><a href="#counting-children">统计子组件</a></p>
</li>
<li><p><a href="#converting-children-to-an-array">转换子组件为数组</a></p>
</li>
<li><p><a href="#enforcing-a-single-child">限制单一子组件</a></p>
</li>
</ul>
</li>
<li><p><a href="#editing-children">编辑子组件</a></p>
<ul>
<li><p><a href="#changing-children-props">改变子组件的属性</a></p>
</li>
<li><p><a href="#immutably-cloning-elements">克隆元素</a></p>
</li>
</ul>
</li>
<li><p><a href="#summary">总结</a></p>
</li>
</ul>
<h2 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h2><p>假设我们有一个可以包含若干组件的组件。你会像这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Grid&gt;</div><div class="line">  &lt;Row /&gt;</div><div class="line">  &lt;Row /&gt;</div><div class="line">  &lt;Row /&gt;</div><div class="line">&lt;/Grid&gt;</div></pre></td></tr></table></figure>
<p><a href="http://www.webpackbin.com/Ekg_vyjPz" target="_blank" rel="external"><img src="http://p0.qhimg.com/t010bbcb2b6a99e5ff1.png" alt="呈现的组件，一个包含三行的网格"></a></p>
<p> <a href="http://www.webpackbin.com/Ekg_vyjPz" target="_blank" rel="external">(演示地址)</a></p>
<p>通过<code>props.children</code>，<code>Grid</code>组件可以获得这三个<code>Row</code>组件。父组件通过一个<em>表现容器</em>来渲染这些子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Grid extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>父组件也可以决定不渲染任何子组件或者在渲染他们之前操控它们。比如说，下面这个组件就不渲染任何子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Fullstop extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;h1&gt;Hello world!&lt;/h1&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管你传递哪个组件给上面这个组件，它总是会只显示“Hello world！”。</p>
<blockquote>
<p>注意： 上面例子中的<code>Fullstop</code>组件（非常像HTML的原语），在渲染‘Hello World!’的情况下，不会渲染它的子组件。</p>
</blockquote>
<h3 id="一切都可以是子组件"><a href="#一切都可以是子组件" class="headerlink" title="一切都可以是子组件"></a>一切都可以是子组件</h3><p>在React中，子组件没有必要必须是一个组件，他们可以是任意内容。比方说，我们可以给上面的<code>Grid</code>组件传递文本作为子组件且结果很完美。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Grid&gt;Hello world!&lt;/Grid&gt;</div></pre></td></tr></table></figure>
<p><a href="http://www.webpackbin.com/N1FUPocvz" target="_blank" rel="external"><img src="http://p0.qhimg.com/t0104c88ec2d04f7863.png" alt="网格组件渲染“Hello World！”"></a></p>
<p> <a href="http://www.webpackbin.com/N1FUPocvz" target="_blank" rel="external">(演示地址)</a></p>
<p>JSX会自动清除每行开始和结束处的空格以及空白的行。它还将字符串文字中间的空行浓缩成一个空格。</p>
<p>这意味着下面这些示例都会渲染成相同的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Grid&gt;Hello world!&lt;/Grid&gt;</div><div class="line"></div><div class="line">&lt;Grid&gt;</div><div class="line">  Hello world!</div><div class="line">&lt;/Grid&gt;</div><div class="line"></div><div class="line">&lt;Grid&gt;</div><div class="line">  Hello</div><div class="line">  world!</div><div class="line">&lt;/Grid&gt;</div><div class="line"></div><div class="line">&lt;Grid&gt;</div><div class="line"></div><div class="line">  Hello world!</div><div class="line">&lt;/Grid&gt;</div></pre></td></tr></table></figure>
<p>你还可以很好地混合和搭配多种类型的子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Grid&gt;</div><div class="line">  Here is a row:</div><div class="line">  &lt;Row /&gt;</div><div class="line">  Here is another row:</div><div class="line">  &lt;Row /&gt;</div><div class="line">&lt;/Grid&gt;</div></pre></td></tr></table></figure>
<p><a href="http://www.webpackbin.com/E1IpLQ3PM" target="_blank" rel="external"><img src="http://p0.qhimg.com/t011cf669dce73c8747.png" alt="呈现两行和一些文本的网格组件"></a></p>
<p> <a href="http://www.webpackbin.com/E1IpLQ3PM" target="_blank" rel="external">(演示地址)</a></p>
<h3 id="函数子组件"><a href="#函数子组件" class="headerlink" title="函数子组件"></a>函数子组件</h3><p>我们可以传递任何JavaScript表达式作为子组件，当然包括函数。</p>
<p>为了说明它看起来是什么样子，下面的组件渲染的就是一个传递给它的函数子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Executioner extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    // 请看我们如何调用一个函数子组件?</div><div class="line">    //                        ↓</div><div class="line">    return this.props.children()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会像这样使用这个组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Executioner&gt;</div><div class="line">  &#123;() =&gt; &lt;h1&gt;Hello World!&lt;/h1&gt;&#125;</div><div class="line">&lt;/Executioner&gt;</div></pre></td></tr></table></figure>
<p>这个具体的例子当然没有什么用，但它说明了这个想法。</p>
<p>假设必须从服务器获取一些数据。你可能有多种方式做到这一点，但是通过下面的函数子组件也可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Fetch url=&quot;api.myself.com&quot;&gt;</div><div class="line">  &#123;(result) =&gt; &lt;p&gt;&#123;result&#125;&lt;/p&gt;&#125;</div><div class="line">&lt;/Fetch&gt;</div></pre></td></tr></table></figure>
<p>花一分钟来看一下<a href="http://www.webpackbin.com/NymfRpcwf" target="_blank" rel="external">这个</a>，看看你能否明白它是如何工作的。(<a href="http://www.webpackbin.com/NkoIz1owG" target="_blank" rel="external">这里</a>是我的看法)</p>
<p>如果这超出了你的认知，不要担心。我只是想让你在看到这些的时候不感到意外。有了子组件，什么都可以做。</p>
<h2 id="操控子组件"><a href="#操控子组件" class="headerlink" title="操控子组件"></a>操控子组件</h2><p>如果你看过React的文档，你会发现它有说“子组件是一种不透明的数据结构”。他们本质上，是想告诉我们<code>props.children</code>可以是任意类型，比如数组、函数、对象等等，因为你可以传递任何内容，所以你永远也不能确定它。</p>
<p>React提供了一系列帮助函数，使操作子组件变得轻松和惬意。它们都在<code>React.Children</code>上适用。</p>
<h3 id="遍历子组件"><a href="#遍历子组件" class="headerlink" title="遍历子组件"></a>遍历子组件</h3><p>最明显的两个帮助类函数是<code>React.Children.map</code> 和 <code>React.Children.forEach</code>。它们和数组中的map及foreach工作完全相同，除了一点：当子组件是函数、对象或者任何内容时，它们仍能正常工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class IgnoreFirstChild extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    const children = this.props.children</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;React.Children.map(children, (child, i) =&gt; &#123;</div><div class="line">          // 忽略第一个子组件</div><div class="line">          if (i &lt; 1) return</div><div class="line">          return child</div><div class="line">        &#125;)&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>IgnoreFirstChild</code>组件遍历它所有的子组件，忽略掉第一个子组件，渲染剩余子组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;IgnoreFirstChild&gt;</div><div class="line">  &lt;h1&gt;First&lt;/h1&gt;</div><div class="line">  &lt;h1&gt;Second&lt;/h1&gt; // &lt;- 只有这个被渲染</div><div class="line">&lt;/IgnoreFirstChild&gt;</div></pre></td></tr></table></figure>
<p><a href="http://www.webpackbin.com/NyfgFQ2wz" target="_blank" rel="external"><img src="http://p0.qhimg.com/t0184ec2f0a130b15df.png" alt="&#39;Second&#39;文本"></a></p>
<p> <a href="http://www.webpackbin.com/NyfgFQ2wz" target="_blank" rel="external">(演示地址)</a></p>
<p>在这种情况下，我们也可以使用<code>this.props.children.map</code>。但是，如果有人传进来一个函数子组件会发生什么？<code>this.props.children</code>将会是一个函数而不是数组，我们会看到一个报错！ ?</p>
<p><img src="http://p0.qhimg.com/t0124e5d89657e560f1.png" alt="TypeError: this.props.children.map is not a function"></p>
<p>然而使用<code>React.Children.map</code>函数，就不会发生这种问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;IgnoreFirstChild&gt;</div><div class="line">  &#123;() =&gt; &lt;h1&gt;First&lt;/h1&gt;&#125; // &lt;- 忽略掉 ?</div><div class="line">&lt;/IgnoreFirstChild&gt;</div></pre></td></tr></table></figure>
<h3 id="统计子组件"><a href="#统计子组件" class="headerlink" title="统计子组件"></a>统计子组件</h3><p>由于<code>this.props.children</code>可以是任意类型，统计一个组件有多少子组件是一件很困难的事情。当传递的子组件是一个字符串或者函数时，使用<code>this.props.children.length</code>就会失效。比方说，我们有一个子组件，<code>&quot;Hello World!&quot;</code>，但是<code>.length</code>将会是<code>12</code>。</p>
<p>这就是为什么我们会有<code>React.Children.count</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ChildrenCounter extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;p&gt;React.Children.count(this.props.children)&lt;/p&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会返回子组件的数量，不管子组件的类型是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Renders &quot;1&quot;</div><div class="line">&lt;ChildrenCounter&gt;</div><div class="line">  Second!</div><div class="line">&lt;/ChildrenCounter&gt;</div><div class="line"></div><div class="line">// Renders &quot;2&quot;</div><div class="line">&lt;ChildrenCounter&gt;</div><div class="line">  &lt;p&gt;First&lt;/p&gt;</div><div class="line">  &lt;ChildComponent /&gt;</div><div class="line">&lt;/ChildrenCounter&gt;</div><div class="line"></div><div class="line">// Renders &quot;3&quot;</div><div class="line">&lt;ChildrenCounter&gt;</div><div class="line">  &#123;() =&gt; &lt;h1&gt;First!&lt;/h1&gt;&#125;</div><div class="line">  Second!</div><div class="line">  &lt;p&gt;Third!&lt;/p&gt;</div><div class="line">&lt;/ChildrenCounter&gt;</div></pre></td></tr></table></figure>
<h3 id="转换子组件为数组"><a href="#转换子组件为数组" class="headerlink" title="转换子组件为数组"></a>转换子组件为数组</h3><p>作为最后的手段，如果上面的方法都不满足你的的需求，你可以使用<code>React.Children.toArray</code>将你的子组件转换为一个数组。这将会很有用，如果你需要比方说将它们排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Sort extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    const children = React.Children.toArray(this.props.children)</div><div class="line">    // 排序并渲染子组件</div><div class="line">    return &lt;p&gt;&#123;children.sort().join(&apos; &apos;)&#125;&lt;/p&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Sort&gt;</div><div class="line">  // 我们使用花括号来确保我们的字符串是作为三个子组件传入，</div><div class="line">  // 而不是一个。</div><div class="line">  &#123;&apos;bananas&apos;&#125;&#123;&apos;oranges&apos;&#125;&#123;&apos;apples&apos;&#125;</div><div class="line">&lt;/Sort&gt;</div></pre></td></tr></table></figure>
<p>上面的例子渲染出字符串，但是是排序后的：</p>
<p><a href="http://www.webpackbin.com/NyE2TQhwz" target="_blank" rel="external"><img src="http://p0.qhimg.com/t01fa935d8e5a8ba261.png" alt="apples bananas oranges"></a></p>
<p> <a href="http://www.webpackbin.com/NyE2TQhwz" target="_blank" rel="external">(演示地址)</a></p>
<h3 id="限制单一子组件"><a href="#限制单一子组件" class="headerlink" title="限制单一子组件"></a>限制单一子组件</h3><p>回想我们上面的<code>Executioner</code>组件，它只希望传递过来一个子组件，并且还必须是一个函数子组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Executioner extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return this.props.children()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以用<code>proptypes</code>来控制，它看起来会像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Executioner.propTypes = &#123;</div><div class="line">  children: React.PropTypes.func.isRequired,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将把信息记录到控制台，然而有些开发者可能会忽略掉这里的报警信息。因此，取而代之，我们可以在<code>render</code>方法中使用<code>React.Children.only</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Executioner extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return React.Children.only(this.props.children)()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将返回<code>this.props.children</code>中唯一的子组件。如果多余一个子组件，它就会抛出一个错误，因此，可以降低我们应用变得不完美的风险，可以避免懒惰的开发者试图扰乱我们的组件。?</p>
<h2 id="编辑子组件"><a href="#编辑子组件" class="headerlink" title="编辑子组件"></a>编辑子组件</h2><p>我们不仅可以通过子组件的方式，渲染任意组件，而且还可以通过父组件来控制它们，而不是在子组件内部。为了说明这点，假设我们有一个<code>RadioGroup</code>组件，这个组件中包含多个<code>RadioButton</code>组件（渲染一个单选框）。</p>
<p>这些<code>RadioButton</code>组件并不是在<code>RadioGroup</code>组件中渲染的，它们是作为子组件被渲染的。这意味着在我们应用的某个地方有这个组件的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  return(</div><div class="line">    &lt;RadioGroup&gt;</div><div class="line">      &lt;RadioButton value=&quot;first&quot;&gt;First&lt;/RadioButton&gt;</div><div class="line">      &lt;RadioButton value=&quot;second&quot;&gt;Second&lt;/RadioButton&gt;</div><div class="line">      &lt;RadioButton value=&quot;third&quot;&gt;Third&lt;/RadioButton&gt;</div><div class="line">    &lt;/RadioGroup&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这里的代码有一个问题。这些<code>input</code>组件并没有被组合起来，这将会导致下面的结果：</p>
<p><a href="http://www.webpackbin.com/Vk-Vt_VawM" target="_blank" rel="external"><img src="http://p0.qhimg.com/t0101a2b0531b777f75.png" alt="三单选按钮，全部选定"></a></p>
<p> <a href="http://www.webpackbin.com/Vk-Vt_VawM" target="_blank" rel="external">(演示地址)</a></p>
<p>要将<code>input</code>标签组合在一起，它们都需要具有相同的<code>name</code>属性。我们当然可以为每一个<code>RadioButton</code>组件指定一个<code>name</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;RadioGroup&gt;</div><div class="line">  &lt;RadioButton name=&quot;g1&quot; value=&quot;first&quot;&gt;First&lt;/RadioButton&gt;</div><div class="line">  &lt;RadioButton name=&quot;g1&quot; value=&quot;second&quot;&gt;Second&lt;/RadioButton&gt;</div><div class="line">  &lt;RadioButton name=&quot;g1&quot; value=&quot;third&quot;&gt;Third&lt;/RadioButton&gt;</div><div class="line">&lt;/RadioGroup&gt;</div></pre></td></tr></table></figure>
<p>但那是乏味和容易出错的。我们掌握了JavaScript的全部力量！我们能否使用它来告诉我们的<code>RadioGroup</code>组件，我们想要添加在所有子组件上的<code>name</code>属性，并让它自动添加呢？</p>
<h3 id="改变子组件的属性"><a href="#改变子组件的属性" class="headerlink" title="改变子组件的属性"></a>改变子组件的属性</h3><p>在<code>RadioGroup</code>组件中，我们将会增加一个新的叫<code>renderChildren</code>的方法，用这个方法，我们可以修改子组件的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class RadioGroup extends React.Component &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    super()</div><div class="line">    // 将方法绑定到组件上下文</div><div class="line">    this.renderChildren = this.renderChildren.bind(this)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  renderChildren() &#123;</div><div class="line">    // TODO: 修改所有子组件的name属性为this.props.name</div><div class="line">    return this.props.children</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;this.renderChildren()&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们以遍历所有的子组件，来获取到每一个单独的子组件开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">renderChildren() &#123;</div><div class="line">  return React.Children.map(this.props.children, child =&gt; &#123;</div><div class="line">	// TODO: 改变name属性为this.props.name</div><div class="line">    return child</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而我们改如何编辑它们的属性呢？</p>
<h3 id="克隆元素"><a href="#克隆元素" class="headerlink" title="克隆元素"></a>克隆元素</h3><p>这就是今天最后一个帮助方法发挥作用的地方了。顾名思义，<code>React.cloneElement</code>会克隆一个元素。我们将要克隆的元素作为第一个参数传递给它，然后第二个参数，我们可以传递一个对象，这个对象中包含的就是我们希望在克隆元素上出现的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const cloned = React.cloneElement(element, &#123;</div><div class="line">  new: &apos;yes!&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个<code>cloned</code>元素现在就有了一个值为<code>&quot;yes!&quot;</code>的<code>new</code>属性。</p>
<p>这正是我们完成<code>RadioGroup</code>组件所需要的。我们克隆每一个子组件，并且把克隆子组件的<code>name</code>属性设置为<code>this.props.name</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">renderChildren() &#123;</div><div class="line">  return React.Children.map(this.props.children, child =&gt; &#123;</div><div class="line">    return React.cloneElement(child, &#123;</div><div class="line">      name: this.props.name</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后一步是为<code>RadioGroup</code>组件设置一个唯一的<code>name</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;RadioGroup name=&quot;g1&quot;&gt;</div><div class="line">  &lt;RadioButton value=&quot;first&quot;&gt;First&lt;/RadioButton&gt;</div><div class="line">  &lt;RadioButton value=&quot;second&quot;&gt;Second&lt;/RadioButton&gt;</div><div class="line">  &lt;RadioButton value=&quot;third&quot;&gt;Third&lt;/RadioButton&gt;</div><div class="line">&lt;/RadioGroup&gt;</div></pre></td></tr></table></figure>
<p><a href="http://www.webpackbin.com/41gz34aDM" target="_blank" rel="external"><img src="http://p0.qhimg.com/t0153e07c620c7a3585.png" alt="三个单选按钮，其中一个选中"></a></p>
<p> <a href="http://www.webpackbin.com/41gz34aDM" target="_blank" rel="external">(演示地址)</a></p>
<p>成功了！? 取代手动地去设置每一个<code>RadioButton</code>组件的<code>name</code>属性，我们只需要告诉<code>RadioGroup</code>组件我们想要的<code>name</code>属性值，它就会自动地去做好了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>子组件使React组件看起来就像一系列的标记，而不是分割的个体。使用JavaScript和React的帮助类函数，我们可以创建声明类的API，让我们的开发更轻松。</p>
<p>非常感谢<a href="https://twitter.com/karlhorky" target="_blank" rel="external">Karl Horky</a> 和 <a href="http://jaketrent.com/post/send-props-to-children-react/" target="_blank" rel="external">Jake Trent</a>。<br>​                </p>
</div><div class="tags"><a href="/tags/React-众成翻译/">React 众成翻译</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/09/01/Javascript-ES6-—-探究新的内置方法/" class="pre">Javascript ES6 — 探究新的内置方法</a><a href="/2017/06/12/快来围观BEM方法论/" class="next">快来围观BEM方法论</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#目录"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子组件"><span class="toc-text">子组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一切都可以是子组件"><span class="toc-text">一切都可以是子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数子组件"><span class="toc-text">函数子组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操控子组件"><span class="toc-text">操控子组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历子组件"><span class="toc-text">遍历子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统计子组件"><span class="toc-text">统计子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换子组件为数组"><span class="toc-text">转换子组件为数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限制单一子组件"><span class="toc-text">限制单一子组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编辑子组件"><span class="toc-text">编辑子组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#改变子组件的属性"><span class="toc-text">改变子组件的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#克隆元素"><span class="toc-text">克隆元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/webpack插件编写/">webpack插件编写</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/四角切角的实现/">四角切角的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/指令式编程-VS-声明式编程/">指令式编程 VS 声明式编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/01/记切角在工作中的一次使用/">记切角在工作中的一次使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/半椭圆/">如何将元素设置成半圆/半椭圆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/适配iPhoneX（持续更新）/">适配iPhoneX（持续更新）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/水平条纹和斜向条纹/">水平条纹和斜向条纹</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/让我们一起创建一个-JavaScript-Wait函数–-Hacker-Noon/">让我们一起创建一个 JavaScript Wait函数– Hacker Noon</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/18/移动端兼容性（持续更新）/">移动端兼容性（持续更新）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/15/多重边框/">多重边框</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/CSS3-linear-gradient/" style="font-size: 15px;">CSS3 linear-gradient</a> <a href="/tags/HTML-PS/" style="font-size: 15px;">HTML PS</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/CSS3-切角/" style="font-size: 15px;">CSS3 切角</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JavaScript-元编程-众成翻译/" style="font-size: 15px;">JavaScript 元编程 众成翻译</a> <a href="/tags/JavaScript-众成翻译/" style="font-size: 15px;">JavaScript 众成翻译</a> <a href="/tags/HTML-CSS/" style="font-size: 15px;">HTML CSS</a> <a href="/tags/React-众成翻译/" style="font-size: 15px;">React 众成翻译</a> <a href="/tags/PostCSS-众成翻译/" style="font-size: 15px;">PostCSS 众成翻译</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">管木凯.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>