<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客、前端"><title>JavaScript中函数的千面—Bocoup | 凯小木的个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript中函数的千面—Bocoup</h1><a id="logo" href="/.">凯小木的个人博客</a><p class="description">天道酬勤</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript中函数的千面—Bocoup</h1><div class="post-meta"><a href="/2017/05/24/JavaScript中函数的千面—Bocoup/#comments" class="comment-count"></a><p><span class="date">May 24, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="JavaScript中函数的千面—Bocoup"><a href="#JavaScript中函数的千面—Bocoup" class="headerlink" title="JavaScript中函数的千面—Bocoup"></a>JavaScript中函数的千面—Bocoup</h2><blockquote>
<p>在众成翻译译文</p>
</blockquote>
<p>如果你曾经接触过JavaScript编程，你一定不会陌生如何定义并且调用一个函数。但是你知道在JavaScript中有多少种定义函数的方法吗？如果想要在<a href="https://github.com/tc39/test262" target="_blank" rel="external">Test262</a>中编写和维护这些方法的测试，那可真是一个很大的挑战，尤其当一些新特性和现有函数语法相关，或者扩展了函数的API时。但是，想要断言新提出或被提案的语法、API有效时，测试所有既存变式又是非常必要的。<br>下面会针对JavaScript中已经存在的函数定义方式进行一个概述。本文不包含Class声明和表达式，因为这些方式创建的对象是“不可调用的”，本文旨在那些可生成“可调用”对象的函数定义方式。也就是说，我们不会研究那些复杂的参数列表（包含默认参数、结构赋值或者尾后逗号），因为那足够另起文章介绍了。</p>
<h3 id="以前的方式"><a href="#以前的方式" class="headerlink" title="以前的方式"></a>以前的方式</h3><h3 id="函数声明以及函数表达式"><a href="#函数声明以及函数表达式" class="headerlink" title="函数声明以及函数表达式"></a>函数声明以及函数表达式</h3><p>最为出名以及应用最广的同样也是这些旧方式：函数声明和函数表达式。前者设计（1995）和出现在<a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf" target="_blank" rel="external">第一版的规范（1997）</a>（pdf）中。后者则是出现在<a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf" target="_blank" rel="external">第三版中（1999）</a>(pdf)。仔细研究，你会从它们当中提取出三种不同的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">function BindingIdentifier() &#123;&#125;</div><div class="line"></div><div class="line">// 命名函数表达式</div><div class="line">// (BindingIdentifier在函数外部是访问不到的)</div><div class="line">(function BindingIdentifier() &#123;&#125;); </div><div class="line"></div><div class="line">// 匿名函数表达式</div><div class="line">(function() &#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>值得注意的是，匿名函数表达式仍然可能有名字，Mike Pennisi在<a href="https://bocoup.com/blog/whats-in-a-function-name" target="_blank" rel="external">什么是函数名称？</a>中有深度解释。</p>
<h3 id="Function构造函数"><a href="#Function构造函数" class="headerlink" title="Function构造函数"></a><code>Function</code>构造函数</h3><p>当研究一门语言的”function API”的时候，也就到了这门语言的底层。在这门语言的设计之初，函数声明方式可以被理解为是<code>Function</code>构造函数API的最直接实现。<code>Function</code>构造函数提供了一种定义函数的方式：通过指明<code>Function</code>的参数，其中最后一个参数就是函数的函数体（必须要说明的是，这是一种动态代码方式，可能存在安全问题）。在大多数情况下，这种方式是不合适的，所以用的人很少，但是在第一版的ECMAScript中，这种方式就出现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x ** y;&apos;);`</div></pre></td></tr></table></figure></p>
<h3 id="新的方式"><a href="#新的方式" class="headerlink" title="新的方式"></a>新的方式</h3><p>自从<a href="https://www.ecma-international.org/ecma-262/6.0/index.html" target="_blank" rel="external">ES2015</a>发布以来，几种新的定义函数方式被引入进来，这些方式的变式更是非常繁多。</p>
<h3 id="另类匿名函数"><a href="#另类匿名函数" class="headerlink" title="另类匿名函数"></a>另类匿名函数</h3><p>这是一种新式的匿名函数。如果你曾经接触过ES的模块化，那么你很有可能已经接触过这种定义函数的方式了。尽管这种方式看起来和匿名函数的定义方式很像，但是他确实有自己的名字：<a href="https://tc39.github.io/ecma262/#sec-function-definitions-static-semantics-boundnames" target="_blank" rel="external"><strong>default</strong></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 另类匿名函数声明</div><div class="line">export default function() &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>顺便一提，这个名字并不是专属的标识，并没有进行绑定。</p>
<h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>下面这些方式定义的函数表达式、匿名函数或者命名函数，都是某个对象的属性。注意这些并不是新的语法，只是应用上面提及的那些语法，写在了某个对象的初始化器中。这种方式最早引入在ES3中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let object = &#123;</div><div class="line">  propertyName: function() &#123;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let object = &#123;</div><div class="line">  // (BindingIdentifier不能再函数外部调用)</div><div class="line">  propertyName: function BindingIdentifier() &#123;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面是存取器属性，引入在ES5。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let object = &#123;</div><div class="line">  get propertyName() &#123;&#125;,</div><div class="line">  set propertyName(value) &#123;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在ES2015中，JavaScript中提供了一种定义方法的简洁语法，不管是直接命名的方式还是计算属性名的方式，都可以使用，而且，存取器同样适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let object = &#123;</div><div class="line">  propertyName() &#123;&#125;,</div><div class="line">  [&quot;computedName&quot;]() &#123;&#125;,</div><div class="line">  get [&quot;computedAccessorName&quot;]() &#123;&#125;,</div><div class="line">  set [&quot;computedAccessorName&quot;](value) &#123;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>你也可以把这些定义属性或者方法的新方式应用在创建类时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 类声明</div><div class="line">class C &#123;</div><div class="line">  methodName() &#123;&#125;</div><div class="line">  [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">  get [&quot;computedAccessorName&quot;]() &#123;&#125;</div><div class="line">  set [&quot;computedAccessorName&quot;](value) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类表达式</div><div class="line">let C = class &#123;</div><div class="line">  methodName() &#123;&#125;</div><div class="line">  [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">  get [&quot;computedAccessorName&quot;]() &#123;&#125;</div><div class="line">  set [&quot;computedAccessorName&quot;](value) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>…在定义静态方法时，同样可以使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 类声明</div><div class="line">class C &#123;</div><div class="line">  static methodName() &#123;&#125;</div><div class="line">  static [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">  static get [&quot;computedAccessorName&quot;]() &#123;&#125;</div><div class="line">  static set [&quot;computedAccessorName&quot;](value) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类表达式</div><div class="line">let C = class &#123;</div><div class="line">  static methodName() &#123;&#125;</div><div class="line">  static [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">  static get [&quot;computedAccessorName&quot;]() &#123;&#125;</div><div class="line">  static set [&quot;computedAccessorName&quot;](value) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数首次出现在ES2015中，尽管起初饱受争议，但是现在已经被广泛应用了。箭头函数的定义根据是否简写有两种不同的语法：赋值表达式（在箭头后面没有花括号）和函数体（当函数包含零个或者多个表达式时）。语法规定，当函数只有一个参数时，可以不用小括号括起来，但是当没有参数或者多余一个参数时，就必须用小括号括起来了。（这种语法就决定了箭头函数会有多种定义形式）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 零参数, 赋值表达式 </div><div class="line">(() =&gt; 2 ** 2);</div><div class="line"></div><div class="line">// 一个参数, 可以省略小括号, 赋值表达式 </div><div class="line">(x =&gt; x ** 2);</div><div class="line"></div><div class="line">// 一个参数, 可以省略小括号, 函数体</div><div class="line">(x =&gt; &#123; return x ** 2; &#125;);</div><div class="line"></div><div class="line">// 多个参数, 赋值表达式</div><div class="line">((x, y) =&gt; x ** y);</div></pre></td></tr></table></figure></p>
<p>上面的最后一种形式中，参数是用参数列表来表示的，因为它们用小括号括了起来。类似于用小括号来标识参数列表的语法，还有其他形式，诸如<code>({ x }) =&gt; x</code>。<br>如果参数不用小括号括起来，那么只能给参数起一个独一的标识符名称，以在箭头函数中使用。当箭头函数被定义为异步函数或者Generator函数时，这个标识符名称还可以加上<code>await</code> 或者 <code>yield</code>的前缀，但那也已经是在不用括号情形中，考虑足够深远的了。<br>箭头函数可以并且也经常出现在初始化器或者对象属性的定义中，但是这种情况大部分使用的是上面介绍的赋值表达式形式，举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let foo = x =&gt; x ** 2;</div><div class="line"></div><div class="line">let object = &#123;</div><div class="line">  propertyName: x =&gt; x ** 2</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p>Generator函数的语法是在其他定义函数的方式上加点东西，但箭头函数和存取器方法除外。你可以使用和之前函数声明，函数表达式，函数定义甚至是构造函数等相似的方式。所有方法列举如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// Generator 声明</div><div class="line">function *BindingIdentifer() &#123;&#125;</div><div class="line"></div><div class="line">// 另类匿名 Generator 声明</div><div class="line">export default function *() &#123;&#125;</div><div class="line"></div><div class="line">// Generator 表达式</div><div class="line">// (BindingIdentifier只能在函数内部调用)</div><div class="line">(function *BindingIdentifier() &#123;&#125;);</div><div class="line"></div><div class="line">// 匿名 Generator 表达式</div><div class="line">(function *() &#123;&#125;);</div><div class="line"></div><div class="line">// 方法定义</div><div class="line">let object = &#123;</div><div class="line">  *methodName() &#123;&#125;,</div><div class="line">  *[&quot;computedName&quot;]() &#123;&#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 在类声明中定义方法</div><div class="line">class C &#123;</div><div class="line">  *methodName() &#123;&#125;</div><div class="line">  *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在类声明中定义静态方法</div><div class="line">class C &#123;</div><div class="line">  static *methodName() &#123;&#125;</div><div class="line">  static *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在类表达式中定义方法</div><div class="line">let C = class &#123;</div><div class="line">  *methodName() &#123;&#125;</div><div class="line">  *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 在类表达式中定义静态方法</div><div class="line">let C = class &#123;</div><div class="line">  static *methodName() &#123;&#125;</div><div class="line">  static *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h3><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>经过几年的发展，异步函数将会发布ES2017——第八版EcmaScript语言规范——规范会在2017年6月在正式发布。但其实，很多开发者早已经开始使用异步函数了，这还要归功于<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>的支持。<br>异步函数语法提供了一个干净的、统一的方式来描述异步操作。当被调用时，异步函数会返回一个Promise对象。当异步执行结束后，这个Promise对象即会被相应执行。当函数中含有<code>await</code>表达式时，异步函数就会暂停执行，这时，<code>await</code>表达式结果就会作为异步函数的返回值。<br>异步函数的语法并没有太多的不同，只是在我们熟知的那些方式前面加上一个前缀：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//  异步函数声明</div><div class="line">async function BindingIdentifier() &#123; /**/ &#125;</div><div class="line"></div><div class="line">// 另类匿名异步函数声明</div><div class="line">export default async function() &#123; /**/ &#125;</div><div class="line"></div><div class="line">// 命名异步函数表达式</div><div class="line">// (BindingIdentifier只能在函数内部调用)</div><div class="line">(async function BindingIdentifier() &#123;&#125;);</div><div class="line"></div><div class="line">// 匿名异步函数表达式</div><div class="line">(async function() &#123;&#125;);</div><div class="line"></div><div class="line">// 异步方法</div><div class="line">let object = &#123;</div><div class="line">  async methodName() &#123;&#125;,</div><div class="line">  async [&quot;computedName&quot;]() &#123;&#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 类声明中的异步方法</div><div class="line">class C &#123;</div><div class="line">  async methodName() &#123;&#125;</div><div class="line">  async [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类声明中的静态异步方法</div><div class="line">class C &#123;</div><div class="line">  static async methodName() &#123;&#125;</div><div class="line">  static async [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类表达式中的异步方法</div><div class="line">let C = class &#123;</div><div class="line">  async methodName() &#123;&#125;</div><div class="line">  async [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 类表达式中的静态异步方法</div><div class="line">let C = class &#123;</div><div class="line">  static async methodName() &#123;&#125;</div><div class="line">  static async [&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="异步箭头函数"><a href="#异步箭头函数" class="headerlink" title="异步箭头函数"></a>异步箭头函数</h3><p><code>async</code> 和 <code>await</code>并不是只局限在常规函数的声明或者表达式中，它们同样适用于箭头函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 单一参数，赋值表达式</div><div class="line">(async x =&gt; x ** 2);</div><div class="line"></div><div class="line">// 单一参数，函数体</div><div class="line">(async x =&gt; &#123; return x ** 2; &#125;);</div><div class="line"></div><div class="line">// 参数列表，赋值表达式</div><div class="line">(async (x, y) =&gt; x ** y);</div><div class="line"></div><div class="line">// 参数列表，函数体</div><div class="line">(async (x, y) =&gt; &#123; return x ** y; &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="与ES2017结合"><a href="#与ES2017结合" class="headerlink" title="与ES2017结合"></a>与ES2017结合</h3><h3 id="异步Generator函数"><a href="#异步Generator函数" class="headerlink" title="异步Generator函数"></a>异步Generator函数</h3><p>和ES2017结合，<code>async</code> 和 <code>await</code>将会被扩展支持异步函数。这一特性的发展可以追踪<a href="https://github.com/tc39/proposal-async-iteration" target="_blank" rel="external">推荐的github仓储</a>。正如你猜想到的，异步Generator函数的语法是结合<code>async</code>、<code>await</code>以及已经存在的Generator函数声明和表达式而来。当异步Generator函数被调用的时候，会返回一个迭代器，这个迭代器的<code>next()</code>方法会返回一个Promise对象来处理迭代器的返回对象，而不是直接返回迭代器的结果对象。<br>异步Generator函数已经开始在很多地方使用，你很有可能已经碰到过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 异步Generator声明</div><div class="line">async function *BindingIdentifier() &#123; /**/ &#125;</div><div class="line"></div><div class="line">// 另类匿名异步Generator声明</div><div class="line">export default async function *() &#123;&#125;</div><div class="line"></div><div class="line">// 异步Generator表达式</div><div class="line">// (BindingIdentifier只能在函数内部访问)</div><div class="line">(async function *BindingIdentifier() &#123;&#125;);</div><div class="line"></div><div class="line">// 匿名异步Generator表达式</div><div class="line">(async function *() &#123;&#125;);</div><div class="line"></div><div class="line">// 匿名异步Generator方法定义</div><div class="line">let object = &#123;</div><div class="line">  async *propertyName() &#123;&#125;,</div><div class="line">  async *[&quot;computedName&quot;]() &#123;&#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 类声明中异步Generator原型方法定义</div><div class="line">class C &#123;</div><div class="line">  async *propertyName() &#123;&#125;</div><div class="line">  async *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类表达式中异步Generator原型方法定义</div><div class="line">let C = class &#123;</div><div class="line">  async *propertyName() &#123;&#125;</div><div class="line">  async *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 类声明中异步Generator静态方法定义</div><div class="line">class C &#123;</div><div class="line">  static async *propertyName() &#123;&#125;</div><div class="line">  static async *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类表达式中异步Generator静态方法定义</div><div class="line">let C = class &#123;</div><div class="line">  static async *propertyName() &#123;&#125;</div><div class="line">  static async *[&quot;computedName&quot;]() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="一个复杂的挑战"><a href="#一个复杂的挑战" class="headerlink" title="一个复杂的挑战"></a>一个复杂的挑战</h3><p>每一种函数定义方式都伴随着两方面的挑战：学习、使用成本；完善、维护JS运行环境和Test262。每当引入一种新的定义方式，Test262必须测试与之相关的所有语法规则。只使用默认参数语法测试简单的函数声明方式，就设想它也适用于其他所有形式的做法是不明智的。测试以及编写每一个语法规则的任务对于单个人来讲是不合理的，这就导致了测试生成工具的设计和实现。测试生成工具能够确保覆盖所有相关的语法规则。<br>这个项目现在包含了一系列的<a href="https://github.com/tc39/test262/tree/master/src" target="_blank" rel="external">源文件</a>，这些源文件是由不同的测试案例和模板组成的。比如说，<a href="https://github.com/tc39/test262/tree/master/src/arguments" target="_blank" rel="external">各种函数形式中的参数检查</a>，或者<a href="https://github.com/tc39/test262/tree/master/src/function-forms" target="_blank" rel="external">函数形式测试</a>或者不仅限于函数形式，<a href="https://github.com/tc39/test262/tree/master/src/dstr-binding" target="_blank" rel="external">解构赋值绑定</a>和<a href="https://github.com/tc39/test262/tree/master/src/dstr-assignment" target="_blank" rel="external">解构赋值</a>都是可用的。<br>尽管这可能是一个复杂并且长期的任务，但是测试的覆盖范围会随之增加，<a href="https://github.com/tc39/test262/pull/651" target="_blank" rel="external">新bug也总能被捕捉到</a>。</p>
<h3 id="所以为什么知道所有的函数定义形式如此重要？"><a href="#所以为什么知道所有的函数定义形式如此重要？" class="headerlink" title="所以为什么知道所有的函数定义形式如此重要？"></a>所以为什么知道所有的函数定义形式如此重要？</h3><p>如果你不为Test262编写测试的话，列出所有的函数定义形式可能并不是那么重要。现在已经有了<a href="https://github.com/tc39/test262/tree/master/src/function-forms/default" target="_blank" rel="external">一系列的包含这里所列形式的模板</a>，新的测试可以很容易地使用现有的这些模板作为测试的起点。<br>确保EcmaScript规范测试是Test262优先考虑的问题。这直接影响所有的JavaScript运行环境，并且我们测试的越多，覆盖范围就会越广，这有助于新特性更无缝隙地引入，不管你使用的是什么平台。</p>
</div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/06/12/快来围观BEM方法论/" class="pre">快来围观BEM方法论</a><a href="/2017/03/31/NodeJS几行代码搭建服务器的背后/" class="next">NodeJS几行代码搭建服务器的背后</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中函数的千面—Bocoup"><span class="toc-text">JavaScript中函数的千面—Bocoup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#以前的方式"><span class="toc-text">以前的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数声明以及函数表达式"><span class="toc-text">函数声明以及函数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function构造函数"><span class="toc-text">Function构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新的方式"><span class="toc-text">新的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#另类匿名函数"><span class="toc-text">另类匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法定义"><span class="toc-text">方法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generators"><span class="toc-text">Generators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES2017"><span class="toc-text">ES2017</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步函数"><span class="toc-text">异步函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步箭头函数"><span class="toc-text">异步箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与ES2017结合"><span class="toc-text">与ES2017结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步Generator函数"><span class="toc-text">异步Generator函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个复杂的挑战"><span class="toc-text">一个复杂的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#所以为什么知道所有的函数定义形式如此重要？"><span class="toc-text">所以为什么知道所有的函数定义形式如此重要？</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/await会产生异步/">await会产生一个微任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/如何实现自己的Object.assign/">如何实现自己的Object.assign</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/react-redux的connect/">react-redux的connect</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/原React项目SSR化问题/">原React项目SSR化问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/webpack插件编写/">webpack插件编写</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/四角切角的实现/">四角切角的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/指令式编程-VS-声明式编程/">指令式编程 VS 声明式编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/01/记切角在工作中的一次使用/">记切角在工作中的一次使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/半椭圆/">如何将元素设置成半圆/半椭圆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/27/适配iPhoneX（持续更新）/">适配iPhoneX（持续更新）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/CSS3-linear-gradient/" style="font-size: 15px;">CSS3 linear-gradient</a> <a href="/tags/HTML-PS/" style="font-size: 15px;">HTML PS</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/CSS3-切角/" style="font-size: 15px;">CSS3 切角</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JavaScript-元编程-众成翻译/" style="font-size: 15px;">JavaScript 元编程 众成翻译</a> <a href="/tags/JavaScript-众成翻译/" style="font-size: 15px;">JavaScript 众成翻译</a> <a href="/tags/HTML-CSS/" style="font-size: 15px;">HTML CSS</a> <a href="/tags/React-众成翻译/" style="font-size: 15px;">React 众成翻译</a> <a href="/tags/PostCSS-众成翻译/" style="font-size: 15px;">PostCSS 众成翻译</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">管木凯.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>