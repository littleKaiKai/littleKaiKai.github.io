<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客、前端"><title>ES6中的元编程部分3 - Proxies | 凯小木的个人博客</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6中的元编程部分3 - Proxies</h1><a id="logo" href="/.">凯小木的个人博客</a><p class="description">天道酬勤</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ES6中的元编程部分3 - Proxies</h1><div class="post-meta"><a href="/2017/10/31/ES6中的元编程部分3---Proxies/#comments" class="comment-count"></a><p><span class="date">Oct 31, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><blockquote>
<p>翻译于众成翻译</p>
</blockquote>
<p>08 Aug 2016</p>
<p>in<br><a href="https://www.keithcirkel.co.uk/tag/javascript" target="_blank" rel="external">JavaScript</a>,<br><a href="https://www.keithcirkel.co.uk/tag/es6" target="_blank" rel="external">ES6</a>,<br><a href="https://www.keithcirkel.co.uk/tag/metaprogramming" target="_blank" rel="external">Metaprogramming</a></p>
<h1 id="ES6中的元编程部分3-Proxies"><a href="#ES6中的元编程部分3-Proxies" class="headerlink" title="ES6中的元编程部分3 - Proxies"></a>ES6中的元编程部分3 - Proxies</h1><p>在我ES6元编程的第三也是最后一章，请记住，那些文章我写了超过一年的时间，尽管起初我并不想花很长时间。在最后一篇文章，让我们尽可能近地来看一下ES6的反射特征：Proxies。那些看了我目录的人可能已经读了<a href="https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/" target="_blank" rel="external">我上一篇文章，关于介绍ES6 Reflect API的</a>,和 <a href="https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/" target="_blank" rel="external">之前那篇介绍ES6 Symbols的文章</a> — 那些没有提前看并对那些知识点不熟悉人的人，在继续往下读之前，建议您先去看一下，因为这里和Reflect有很大的关联。就像其他的文章一样，我要引用第1部分中的一点：</p>
<blockquote>
<ul>
<li>Symbols是具体实现中的反射——您在现有的类和对象上嵌入它们来改变行为。</li>
</ul>
<ul>
<li>Reflect是通过自省进行的反射——用于发现关于代码底层的信息。</li>
</ul>
<ul>
<li>Proxy是通过中间层来进行反射的——包装对象和通过陷阱拦截他们本来的行为。</li>
</ul>
</blockquote>
<p>所以，<code>Proxy</code>是一种新的全局构造函数（如<code>Date</code>或<code>Number</code>），你传入一个对象和一组处理程序钩子，然后返回一个新对象，这个新对象就是将旧对象用传入的那些钩子包裹起来。这样，你就有了一个proxy！文章结束，希望您喜欢，让我们回家！</p>
<p>好吧，当然还有更多。首先，让我们看一下构造函数。</p>
<h3 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h3><p>Proxy构造函数需要两个参数，一个要代理的初始对象和一组处理程序钩子。让我们暂时忘掉这些钩子，看看我们如何在对象上创建代理。线索就在代理名称：它们对您创建的对象保留了一份参考，但如果您有一个原始参考对象，那么您仍然可以与它进行交互，并且代理对象也会受到影响，同样的，您对代理对象做的任何改变都会反映到原始对象。换句话说，代理返回一个包装传入对象的新对象，但是您对其中一个对象做的任何操作都会影响另一个对象。证明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;&#125;;</div><div class="line">var proxiedMyObject = new Proxy(myObject, &#123;/*handler hooks*/&#125;);</div><div class="line"></div><div class="line">assert(myObject !== proxiedMyObject);</div><div class="line"></div><div class="line">myObject.foo = true;</div><div class="line">assert(proxiedMyObject.foo === true);</div><div class="line"></div><div class="line">proxiedMyObject.bar = true;</div><div class="line">assert(myObject.bar === true);</div></pre></td></tr></table></figure>
<p>到目前为止，我们还没有取得任何成果，我们的代理并没有给我们带来任何好处，除了正常地使用对象。要用它做有趣的事情，我们就需要使用处理程序钩子。</p>
<h3 id="代理处理程序钩子"><a href="#代理处理程序钩子" class="headerlink" title="代理处理程序钩子"></a>代理处理程序钩子</h3><p>处理程序钩子是一系列函数，每个函数都有一个Proxy所知道的特定名称，每个函数控制您与代理对象（被包裹后的新对象）如何进行交互。这些处理程序连通JavaScript的“内部方法”，如果这听起来很熟悉，那是因为我们已经在<a href="https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/#internal-methods" target="_blank" rel="external">关于Reflect API的文章中</a>讨论了内部方法。</p>
<p>好了，是时候揭露秘密了。我有一个很好的理由保存代理直到最后，那是因为我们需要理解Reflect是如何工作的，因为Proxy和Reflect是交织在一起的，就好像一对“苦命恋人”。您知道，每个代理处理程序钩子都有一个反射方法，或者换句话说，每一个反射方法都有一个代理处理钩子。反射方法/代理处理程序钩子的完整列表是：</p>
<ul>
<li><p><code>apply</code> (调用函数，并带有<code>this</code>参数和<code>arguments</code>参数组)</p>
</li>
<li><p><code>construct</code> (调用类函数/构造函数，并带有<code>arguments</code>参数组和原型的可选构造函数)</p>
</li>
<li><p><code>defineProperty</code> (定义一个对象的属性，包括它的可数性和一些元数据)</p>
</li>
<li><p><code>getOwnPropertyDescriptor</code> (得到一个属性”属性说明”：关于某个对象的属性的元数据比如可枚举性)</p>
</li>
<li><p><code>deleteProperty</code> (从对象中删除属性)</p>
</li>
<li><p><code>getPrototypeOf</code> (获取实例原型)</p>
</li>
<li><p><code>setPrototypeOf</code> (设置实例原型)</p>
</li>
<li><p><code>isExtensible</code> (决定一个对象是否是可扩展的（可以给它添加属性）)</p>
</li>
<li><p><code>preventExtensions</code> (阻止对象可扩展)</p>
</li>
<li><p><code>get</code> (获取对象上某个属性的值。)</p>
</li>
<li><p><code>set</code> (设置对象上某个属性的值。)</p>
</li>
<li><p><code>has</code> (检查对象是否具有特定属性，不管属性具体的值)</p>
</li>
<li><p><code>ownKeys</code> (检索对象所有自己的key：自有的key，不算原型上的key)</p>
</li>
</ul>
<p>我把所有这些方法（代码示例）写在了 <a href="https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/" target="_blank" rel="external">Reflect文章</a>中。（再重申一次，如果您还没有读，去读一下）。Proxy实现了其中的每一个，并具有完全相同的参数集。事实上，Proxy的默认行为本质上实现了对每个处理程序钩子的反射调用（JavaScript引擎的内部机制可能略有不同，但我们可以假定未被特殊指明的处理程序钩子会按照它们默认行为执行）。这也意味着任何您未特殊指明的处理程序钩子会表现得像平常一样，就好像从来没有被代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 这个代理，我们指定的行为还是和默认行为一致：</div><div class="line">proxy = new Proxy(&#123;&#125;, &#123;</div><div class="line">  apply: Reflect.apply,</div><div class="line">  construct: Reflect.construct,</div><div class="line">  defineProperty: Reflect.defineProperty,</div><div class="line">  getOwnPropertyDescriptor: Reflect.getOwnPropertyDescriptor,</div><div class="line">  deleteProperty: Reflect.deleteProperty,</div><div class="line">  getPrototypeOf: Reflect.getPrototypeOf,</div><div class="line">  setPrototypeOf: Reflect.setPrototypeOf,</div><div class="line">  isExtensible: Reflect.isExtensible,</div><div class="line">  preventExtensions: Reflect.preventExtensions,</div><div class="line">  get: Reflect.get,</div><div class="line">  set: Reflect.set,</div><div class="line">  has: Reflect.has,</div><div class="line">  ownKeys: Reflect.ownKeys,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在，我可以详细介绍这些代理处理程序钩子的工作原理，但基本上是复制粘贴Reflect的例子，只有一些小的修改。这对Proxy有点不公平，因为Proxy都是很酷的使用案例，而不是单个方法的效用。所以这篇文章的其余部分将向您展示您使用Proxy可以做的很酷的事情，包括一些没有它们您永远也做不到的事情。</p>
<p>另外，为了使事情更具交互性，我为每个示例创建了小的库，这些示例演示了功能。我会为每个例子添加上下载链接。</p>
<h3 id="使用Proxy，可以…"><a href="#使用Proxy，可以…" class="headerlink" title="使用Proxy，可以…"></a>使用Proxy，可以…</h3><h4 id="…完成一个无限链式调用的API"><a href="#…完成一个无限链式调用的API" class="headerlink" title="…完成一个无限链式调用的API"></a>…完成一个无限链式调用的API</h4><p>继续构建之前的例子 —— 使用同样的<code>[[Get]]</code> 陷阱：用一点魔法，我们可以生成一个有无数个方法的API，当您调用其中最后一个方法时，它将返回您所链接的所有东西。这会很有用的，比如在制作可以构建Web请求的URL的<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="external">流畅API</a>的时候，或者是在制作某种测试断言框架的时候，将英语单词链在一起，增强断言的可读性，就像 <a href="https://github.com/chaijs/chai" target="_blank" rel="external">Chai</a>。</p>
<p>为此，我们需要使用<code>[[Get]]</code>钩子，并将要检索属性放入数组中。Proxy包装了一个函数，这个函数返回一个由所有要检索的属性组成的数组，并清空这个数组，以便重新使用。我们也会使用<code>[[HasProperty]]</code>钩子，因为，像以前一样，我们要给我们的用户展示任何属性的存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function urlBuilder(domain) &#123;</div><div class="line">  var parts = [];</div><div class="line">  var proxy = new Proxy(function () &#123;</div><div class="line">    var returnValue = domain + &apos;/&apos; + parts.join(&apos;/&apos;);</div><div class="line">    parts = [];</div><div class="line">    return returnValue;</div><div class="line">  &#125;, &#123;</div><div class="line">    has: function () &#123;</div><div class="line">      return true;</div><div class="line">    &#125;,</div><div class="line">    get: function (object, prop) &#123;</div><div class="line">      parts.push(prop);</div><div class="line">      return proxy;</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line">  return proxy;</div><div class="line">&#125;</div><div class="line">var google = urlBuilder(&apos;http://google.com&apos;);</div><div class="line">assert(google.search.products.bacon.and.eggs() === &apos;http://google.com/search/products/bacon/and/eggs&apos;)</div></pre></td></tr></table></figure>
<p>您也可以使用同样的模式来生成树遍历流畅API，您可能在jQuery中见到过，也可能在React的选择器工具中见到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">function treeTraverser(tree) &#123;</div><div class="line">  var parts = [];</div><div class="line">  var proxy = new Proxy(function (parts) &#123;</div><div class="line">    let node = tree; // 从根节点开始</div><div class="line">    for (part of parts) &#123;</div><div class="line">      if (!node.props || !node.props.children || node.props.children.length === 0) &#123;</div><div class="line">        throw new Error(`Node $&#123;node.tagName&#125; has no more children`);</div><div class="line">      &#125;</div><div class="line">      // 如果这部分是子标签, 深入到那个子节点为了下一步的遍历</div><div class="line">      let index = node.props.children.findIndex((child) =&gt; child.tagName == part);</div><div class="line">      if(index === -1) &#123;</div><div class="line">        throw new Error(`Cannot find child: $&#123;part&#125; in $&#123;node.tagName&#125;`);</div><div class="line">      &#125;</div><div class="line">      node = node.props.children[index];</div><div class="line">    &#125;</div><div class="line">    return node.props;</div><div class="line">  &#125;, &#123;</div><div class="line">    has: function () &#123;</div><div class="line">      return true;</div><div class="line">    &#125;,</div><div class="line">    get: function () &#123;</div><div class="line">      parts.push(prop);</div><div class="line">      return proxy;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  return proxy;</div><div class="line">&#125;</div><div class="line">var myDomIsh = treeTraverserExample(&#123;</div><div class="line">  tagName: &apos;body&apos;,</div><div class="line">  props: &#123;</div><div class="line">    children: [</div><div class="line">      &#123;</div><div class="line">        tagName: &apos;div&apos;,</div><div class="line">        props: &#123;</div><div class="line">          className: &apos;main&apos;,</div><div class="line">          children: [</div><div class="line">            &#123;</div><div class="line">              tagName: &apos;span&apos;,</div><div class="line">              props: &#123;</div><div class="line">                className: &apos;extra&apos;,</div><div class="line">                children: [</div><div class="line">                  &#123; tagName: &apos;i&apos;, props: &#123; textContent: &apos;Hello&apos; &#125; &#125;,</div><div class="line">                  &#123; tagName: &apos;b&apos;, props: &#123; textContent: &apos;World&apos; &#125; &#125;,</div><div class="line">                ]</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">assert(myDomIsh.div.span.i().textContent === &apos;Hello&apos;);</div><div class="line">assert(myDomIsh.div.span.b().textContent === &apos;World&apos;);</div></pre></td></tr></table></figure>
<p>我已经做了一个复用性稍微增强的版本<a href="https://github.com/keithamus/proxy-fluent-api" target="_blank" rel="external">github.com/keithamus/proxy-fluent-api</a>。可以用npm加相同名称直接下载。</p>
<h4 id="…实现“方法丢失”钩子"><a href="#…实现“方法丢失”钩子" class="headerlink" title="…实现“方法丢失”钩子"></a>…实现“方法丢失”钩子</h4><p>其他编程语言使您能够使用已知的反射方法来重写类的行为，比如PHP中的<code>__call</code>，Ruby中的<code>method_missing</code>，Python中可以用<code>__getattr__</code>来模仿。JavaScript没有这样的机制——但是现在我们有了代理，允许我们像这样做一些很酷的事情。</p>
<p>为了弄清楚我们究竟要做什么，让我们来看看Ruby的例子，以获得一些灵感：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Foo</div><div class="line">  def bar()</div><div class="line">    print &quot;you called bar. Good job!&quot;</div><div class="line">  end</div><div class="line">  def method_missing(method)</div><div class="line">    print &quot;you called `#&#123;method&#125;` but it doesn&apos;t exist!&quot;</div><div class="line">  end</div><div class="line">end</div><div class="line"></div><div class="line">foo = Foo.new</div><div class="line">foo.bar()</div><div class="line">#=&gt; you called bar. Good job!</div><div class="line">foo.this_method_does_not_exist()</div><div class="line">#=&gt; you called this_method_does_not_exist but it doesn&apos;t exist</div></pre></td></tr></table></figure>
<p>所以在这个<code>bar</code>例子中，对于已经存在的方法，这个方法就会像您期望的那样被执行。对于不存在的方法，像<code>foo</code>或<code>this_method_does_not_exist</code>，<code>method_missing</code>方法就会代替它们被执行。此外，它将调用的方法名作为第一个参数，这对于确定用户想要什么非常有用。</p>
<p>我们可以使用ES6的Symbols和一个函数来完成类似的功能，这个函数需要包装这个类，并且返回一个使用了<code>get</code> (<code>[[Get]]</code>)陷阱的代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">  return new Proxy(this, &#123;</div><div class="line">    get: function (object, property) &#123;</div><div class="line">      if (Reflect.has(object, property)) &#123;</div><div class="line">        return Reflect.get(object, property);</div><div class="line">      &#125; else &#123;</div><div class="line">        return function methodMissing() &#123;</div><div class="line">          console.log(&apos;you called &apos; + property + &apos; but it doesn\&apos;t exist!&apos;);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.bar = function () &#123;</div><div class="line">  console.log(&apos;you called bar. Good job!&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo = new Foo();</div><div class="line">foo.bar();</div><div class="line">//=&gt; you called bar. Good job!</div><div class="line">foo.this_method_does_not_exist()</div><div class="line">//=&gt; you called this_method_does_not_exist but it doesn&apos;t exist</div></pre></td></tr></table></figure>
<p>如果您有一组方法，它们的功能基本相同，差异可以从名字中区分出来，这就真的非常有用了。实际上，将函数参数加入到函数名称中会得到更可读的语法。举个例子，你可以很容易地制作一个API来交换两种值，比如货币，或者基值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const baseConvertor = new Proxy(&#123;&#125;, &#123;</div><div class="line">  get: function baseConvert(object, methodName) &#123;</div><div class="line">    var methodParts = methodName.match(/base(\d+)toBase(\d+)/);</div><div class="line">    var fromBase = methodParts &amp;&amp; methodParts[1];</div><div class="line">    var toBase = methodParts &amp;&amp; methodParts[2];</div><div class="line">    if (!methodParts || fromBase &gt; 36 || toBase &gt; 36 || fromBase &lt; 2 || toBase &lt; 2) &#123;</div><div class="line">      throw new Error(&apos;TypeError: baseConvertor&apos; + methodName + &apos; is not a function&apos;);</div><div class="line">    &#125;</div><div class="line">    return function (fromString) &#123;</div><div class="line">      return parseInt(fromString, fromBase).toString(toBase);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">baseConvertor.base16toBase2(&apos;deadbeef&apos;) === &apos;11011110101011011011111011101111&apos;;</div><div class="line">baseConvertor.base2toBase16(&apos;11011110101011011011111011101111&apos;) === &apos;deadbeef&apos;;</div></pre></td></tr></table></figure>
<p>当然，您可以手动键入可用的所有1296种排列方式，或者创建一个循环来单独创建所有这些方法，但都需要更多的代码。</p>
<p>这方面的一个更具体的例子体现在Ruby的Rails ActiveRecord，它带有“动态查询”。它实现的<code>method_missing</code>允许您通过它的列来查询列表。而不是传进一个复杂的对象，您传入的参数会去和方法名去匹配，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Users.find_by_first_name(&apos;Keith&apos;); # [ Keith Cirkel, Keith Urban, Keith David ]</div><div class="line">Users.find_by_first_name_and_last_name(&apos;Keith&apos;, &apos;David&apos;);  # [ Keith David ]</div></pre></td></tr></table></figure>
<p>我们可以使用上面的模式在JavaScript中实现类似的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function RecordFinder(options) &#123;</div><div class="line">  this.attributes = options.attributes;</div><div class="line">  this.table = options.table;</div><div class="line">  return new Proxy(&#123;&#125;, function findProxy(methodName) &#123;</div><div class="line">    var match = methodName.match(new RegExp(&apos;findBy((?:And)&apos; + this.attributes.join(&apos;|&apos;) + &apos;)&apos;));</div><div class="line">    if (!match)&#123;</div><div class="line">      throw new Error(&apos;TypeError: &apos; + methodName + &apos; is not a function&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>就如其他的例子，我做了一个小的库在<a href="https://github.com/keithamus/proxy-method-missing" target="_blank" rel="external">github.com/keithamus/proxy-method-missing</a>，同样可以用npm下载。</p>
<h4 id="…隐藏所有属性的枚举性方法包括getOwnPropertyNames-Object-keys-in-等。"><a href="#…隐藏所有属性的枚举性方法包括getOwnPropertyNames-Object-keys-in-等。" class="headerlink" title="…隐藏所有属性的枚举性方法包括getOwnPropertyNames, Object.keys, in 等。"></a>…隐藏所有属性的枚举性方法包括<code>getOwnPropertyNames</code>, <code>Object.keys</code>, <code>in</code> 等。</h4><p>我们可以使用代理使一个对象中的所有属性完全隐藏，除了获取值时。下面是JavaScript中所有判断一个属性是否存在的方法：</p>
<ul>
<li><p><code>Reflect.has</code>,<code>Object.hasOwnProperty</code>,<code>Object.prototype.hasOwnProperty</code>, 以及 <code>in</code> 操作符都是使用<code>[[HasProperty]]</code>。Proxy可以<code>has</code>来实现。</p>
</li>
<li><p><code>Object.keys</code>/<code>Object.getOwnPropertyNames</code>都是使用 <code>[[OwnPropertyKeys]]</code>。 Proxy可以使用<code>ownKeys</code>来实现。</p>
</li>
<li><p><code>Object.entries</code> (即将到来的ES2017特性), 同样使用<code>[[OwnPropertyKeys]]</code> - 同样 - 可以使用<code>ownKeys</code>来实现。</p>
</li>
<li><p><code>Object.getOwnPropertyDescriptor</code> 使用 <code>[[GetOwnProperty]]</code>。意外的惊喜，Proxy可以使用<code>getOwnPropertyDescriptor</code>来实现。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var example = new Proxy(&#123; foo: 1, bar: 2 &#125;, &#123;</div><div class="line">  has: function () &#123; return false; &#125;,</div><div class="line">  ownKeys: function () &#123; return []; &#125;,</div><div class="line">  getOwnPropertyDescriptor: function () &#123; return false; &#125;,</div><div class="line">&#125;);</div><div class="line">assert(example.foo === 1);</div><div class="line">assert(example.bar === 2);</div><div class="line">assert(&apos;foo&apos; in example === false);</div><div class="line">assert(&apos;bar&apos; in example === false);</div><div class="line">assert(example.hasOwnProperty(&apos;foo&apos;) === false);</div><div class="line">assert(example.hasOwnProperty(&apos;bar&apos;) === false);</div><div class="line">assert.deepEqual(Object.keys(example), [ ]);</div><div class="line">assert.deepEqual(Object.getOwnPropertyNames(example), [ ]);</div></pre></td></tr></table></figure>
<p>我不想说谎，我想不出这种模式有什么超级有用的用途。尽管如此，我还是建立了一个库，<a href="https://github.com/keithamus/proxy-hide-properties" target="_blank" rel="external">github.com/keithamus/proxy-hide-properties</a>，它可以帮助您隐藏指定的属性，而不是所有的属性。</p>
<h4 id="…实现观察者模式，又称Object-observe。"><a href="#…实现观察者模式，又称Object-observe。" class="headerlink" title="…实现观察者模式，又称Object.observe。"></a>…实现观察者模式，又称Object.observe。</h4><p>那些敏锐地遵循新规范的人可能已经注意到<code>Object.observe</code>正在被考虑加入到ES2016中。然而，最近，<code>Object.observe</code>的拥护者计划<a href="https://esdiscuss.org/topic/an-update-on-object-observe" target="_blank" rel="external">撤回这个提议</a>，并有很好的理由：它最初设计的目的是为了解决框架作者们碰到的数据绑定问题。现在，有了React和Polymer 1.0，双向数据绑定框架的趋势正在下降，而固定数据结构框架正变得越来越流行。</p>
<p>值得庆幸的是，实际上，Proxy使类似Object.observe的规范变得多余，因为现在通过Proxy我们有一个底层的API，能真正实现类似Object.observe的东西。为了能够十分接近Object.observe，我们需要<code>[[Set]]</code>, <code>[[PreventExtensions]]</code>, <code>[[Delete]]</code>以及<code>[[DefineOwnProperty]]</code>内部的方法 —— <code>set</code>, <code>preventExtensions</code>, <code>deleteProperty</code>和<code>defineProperty</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">function observe(object, observerCallback) &#123;</div><div class="line">  var observing = true;</div><div class="line">  const proxyObject = new Proxy(object, &#123;</div><div class="line">    set: function (object, property, value) &#123;</div><div class="line">      var hadProperty = Reflect.has(object, property);</div><div class="line">      var oldValue = hadProperty &amp;&amp; Reflect.get(object, property);</div><div class="line">      var returnValue = Reflect.set(object, property, value);</div><div class="line">      if (observing &amp;&amp; hadProperty) &#123;</div><div class="line">        observerCallback(&#123; object: proxyObject, type: &apos;update&apos;, name: property, oldValue: oldValue &#125;);</div><div class="line">      &#125; else if(observing) &#123;</div><div class="line">        observerCallback(&#123; object: proxyObject, type: &apos;add&apos;, name: property &#125;);</div><div class="line">      &#125;</div><div class="line">      return returnValue;</div><div class="line">    &#125;,</div><div class="line">    deleteProperty: function (object, property) &#123;</div><div class="line">      var hadProperty = Reflect.has(object, property);</div><div class="line">      var oldValue = hadProperty &amp;&amp; Reflect.get(object, property);</div><div class="line">      var returnValue = Reflect.deleteProperty(object, property);</div><div class="line">      if (observing &amp;&amp; hadProperty) &#123;</div><div class="line">        observerCallback(&#123; object: proxyObject, type: &apos;delete&apos;, name: property, oldValue: oldValue &#125;);</div><div class="line">      &#125;</div><div class="line">      return returnValue;</div><div class="line">    &#125;,</div><div class="line">    defineProperty: function (object, property, descriptor) &#123;</div><div class="line">      var hadProperty = Reflect.has(object, property);</div><div class="line">      var oldValue = hadProperty &amp;&amp; Reflect.getOwnPropertyDescriptor(object, property);</div><div class="line">      var returnValue = Reflect.defineProperty(object, property, descriptor);</div><div class="line">      if (observing &amp;&amp; hadProperty) &#123;</div><div class="line">        observerCallback(&#123; object: proxyObject, type: &apos;reconfigure&apos;, name: property, oldValue: oldValue &#125;);</div><div class="line">      &#125; else if(observing) &#123;</div><div class="line">        observerCallback(&#123; object: proxyObject, type: &apos;add&apos;, name: property &#125;);</div><div class="line">      &#125;</div><div class="line">      return returnValue;</div><div class="line">    &#125;,</div><div class="line">    preventExtensions: function (object) &#123;</div><div class="line">      var returnValue = Reflect.preventExtensions(object);</div><div class="line">      if (observing) &#123;</div><div class="line">        observerCallback(&#123; object: proxyObject, type: &apos;preventExtensions&apos; &#125;)</div><div class="line">      &#125;</div><div class="line">      return returnValue;</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line">  return &#123; object: proxyObject, unobserve: function () &#123; observing = false &#125; &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var changes = [];</div><div class="line">var observer = observe(&#123; id: 1 &#125;, (change) =&gt; changes.push(change));</div><div class="line">var object = observer.object;</div><div class="line">var unobserve = observer.unobserve;</div><div class="line">object.a = &apos;b&apos;;</div><div class="line">object.id++;</div><div class="line">Object.defineProperty(object, &apos;a&apos;, &#123; enumerable: false &#125;);</div><div class="line">delete object.a;</div><div class="line">Object.preventExtensions(object);</div><div class="line">unobserve();</div><div class="line">object.id++;</div><div class="line">assert.equal(changes.length, 5);</div><div class="line">assert.equal(changes[0].object, object);</div><div class="line">assert.equal(changes[0].type, &apos;add&apos;);</div><div class="line">assert.equal(changes[0].name, &apos;a&apos;);</div><div class="line">assert.equal(changes[1].object, object);</div><div class="line">assert.equal(changes[1].type, &apos;update&apos;);</div><div class="line">assert.equal(changes[1].name, &apos;id&apos;);</div><div class="line">assert.equal(changes[1].oldValue, 1);</div><div class="line">assert.equal(changes[2].object, object);</div><div class="line">assert.equal(changes[2].type, &apos;reconfigure&apos;);</div><div class="line">assert.equal(changes[2].oldValue.enumerable, true);</div><div class="line">assert.equal(changes[3].object, object);</div><div class="line">assert.equal(changes[3].type, &apos;delete&apos;);</div><div class="line">assert.equal(changes[3].name, &apos;a&apos;);</div><div class="line">assert.equal(changes[4].object, object);</div><div class="line">assert.equal(changes[4].type, &apos;preventExtensions&apos;);</div></pre></td></tr></table></figure>
<p>您可以看到，我们用一个小代码块实现了相对完整的object.observe。它和提议规范的主要的差异是object.observe可以改变一个对象，而代理返回一个新的对象——observe和unobserve函数都不是全局的。</p>
<h2 id="奖励：可撤销代理"><a href="#奖励：可撤销代理" class="headerlink" title="奖励：可撤销代理"></a>奖励：可撤销代理</h2><p>代理还有最后一个窍门：可以撤销某些代理。为了创建一个可撤销的代理，您需要使用<code>Proxy.revocable(target, handler)</code>（而不是<code>new Proxy(target, handler)</code>），和直接返回代理不同，它会返回一个看起来像<code>{ proxy, revoke(){} }</code>的对象。一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function youOnlyGetOneSafetyNet(object) &#123;</div><div class="line">  var revocable = Proxy.revocable(object, &#123;</div><div class="line">    get(property) &#123;</div><div class="line">      if (Reflect.has(this, property)) &#123;</div><div class="line">        return Reflect.get(this, property);</div><div class="line">      &#125; else &#123;</div><div class="line">        revocable.revoke();</div><div class="line">        return &apos;You only get one safety net&apos;;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  return revocable.proxy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var myObject = youOnlyGetOneSafetyNet(&#123; foo: true &#125;);</div><div class="line"></div><div class="line">assert(myObject.foo === true);</div><div class="line">assert(myObject.foo === true);</div><div class="line">assert(myObject.foo === true);</div><div class="line"></div><div class="line">assert(myObject.bar === &apos;You only get one safety net&apos;);</div><div class="line">myObject.bar // TypeError</div><div class="line">myObject.bar // TypeError</div><div class="line">Reflect.has(myObject, &apos;bar&apos;) // TypeError</div></pre></td></tr></table></figure>
<p>可悲的是，正如您所见，例子的最后，当任一处理函数被触发的时候，被撤销的代理会抛出一个TypeError——甚至是没有设置这些处理函数。我觉得这限制了可撤销代理的能力。如果所有的处理程序返回它们的Reflect等价物（有效地使代理变得冗余，对象的行为就好像从未使用代理），这将是一个更有用的特性。可悲的是，事实并非如此。正因为如此，这个特性一直留在这篇文章的脚注中，因为我不太确定可撤销代理的具体用例。</p>
<p>就好像其他例子，这个例子的库在<a href="https://github.com/keithamus/proxy-object-observe" target="_blank" rel="external">github.com/keithamus/proxy-object-observe</a>——npm同样适用。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我希望这篇文章向您展示了Proxy是一个非常强大的工具，可以用来干扰JavaScript内部机制。在许多方面，Symbol、Reflect和Proxy都打开了JavaScript的新篇章——就好像const和let，或者classes和箭头函数。const和let可以降低代码混乱，classes和箭头函数使得代码更简洁，Symbol，Reflect，和Proxy开始给予开发者关于JavaScript的真正底层的元编程钩子。</p>
<p>这些新的元编程工具的出现不会放缓速度：对于未来EcmaScript版本的提议一直在出现，其他有趣的特性在正在被增加，比如<a href="https://github.com/caitp/TC39-Proposals/blob/master/tc39-reflect-isconstructor-iscallable.md" target="_blank" rel="external">这个针对<code>Reflect.isCallable</code> 和 <code>Reflect.isConstructor</code>的新提议</a>, <a href="https://github.com/alex-weej/es-reflect-type-proposal" target="_blank" rel="external">或者这个针对<code>Reflect.type</code>0阶段的提议</a>, or <a href="https://github.com/allenwb/ESideas/blob/master/Generator%20metaproperty.md" target="_blank" rel="external">这个针对<code>function.sent</code> 元属性的提议</a>, <a href="https://github.com/allenwb/ESideas/blob/master/ES7MetaProps.md" target="_blank" rel="external">或者这一组函数的更多元属性</a>。而且，这些新API启发了一些有趣的关于一些新特性的讨论，比如<a href="https://esdiscuss.org/topic/reflect-parse-from-re-typeof-null" target="_blank" rel="external">这个关于增加 <code>Reflect.parse</code>的提议</a>, 随后引出了围绕生成AST（抽象语法树）标准的讨论。</p>
<p>您觉得新的Proxy API怎么样？计划在您的项目中使用它吗？让我知道，在下面的评论或Twitter<a href="https://twitter.com/keithamus" target="_blank" rel="external">@keithamus</a>上。</p>
</div><div class="tags"><a href="/tags/JavaScript-元编程-众成翻译/">JavaScript 元编程 众成翻译</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2017/11/14/半透明边框/" class="pre">半透明边框</a><a href="/2017/10/13/是时候学习PostCSS了/" class="next">是时候学习PostCSS了 | 它是什么；它究竟做了什么</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6中的元编程部分3-Proxies"><span class="toc-text">ES6中的元编程部分3 - Proxies</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建代理"><span class="toc-text">创建代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理处理程序钩子"><span class="toc-text">代理处理程序钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Proxy，可以…"><span class="toc-text">使用Proxy，可以…</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#…完成一个无限链式调用的API"><span class="toc-text">…完成一个无限链式调用的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#…实现“方法丢失”钩子"><span class="toc-text">…实现“方法丢失”钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#…隐藏所有属性的枚举性方法包括getOwnPropertyNames-Object-keys-in-等。"><span class="toc-text">…隐藏所有属性的枚举性方法包括getOwnPropertyNames, Object.keys, in 等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#…实现观察者模式，又称Object-observe。"><span class="toc-text">…实现观察者模式，又称Object.observe。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#奖励：可撤销代理"><span class="toc-text">奖励：可撤销代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/09/用JavaScript实现二叉树/">用JavaScript实现二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/await会产生异步/">await会产生一个微任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/如何实现自己的Object.assign/">如何实现自己的Object.assign</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/react-redux的connect/">React-Redux的connect</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/原React项目SSR化问题/">原React项目SSR化问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/webpack插件编写/">webpack插件编写</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/四角切角的实现/">四角切角的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/指令式编程-VS-声明式编程/">指令式编程 VS 声明式编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/01/记切角在工作中的一次使用/">记切角在工作中的一次使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/半椭圆/">如何将元素设置成半圆/半椭圆</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript-元编程-众成翻译/" style="font-size: 15px;">JavaScript 元编程 众成翻译</a> <a href="/tags/HTML-PS/" style="font-size: 15px;">HTML PS</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/CSS3-切角/" style="font-size: 15px;">CSS3 切角</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/CSS3-linear-gradient/" style="font-size: 15px;">CSS3 linear-gradient</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JavaScript-众成翻译/" style="font-size: 15px;">JavaScript 众成翻译</a> <a href="/tags/HTML-CSS/" style="font-size: 15px;">HTML CSS</a> <a href="/tags/React-众成翻译/" style="font-size: 15px;">React 众成翻译</a> <a href="/tags/PostCSS-众成翻译/" style="font-size: 15px;">PostCSS 众成翻译</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">管木凯.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>